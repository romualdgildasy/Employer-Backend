"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createValidator = void 0;
var validators_map_1 = require("./validators-map");
var createFieldValidator = function (fieldConfig, fieldName) {
    var validationsPipeLine = [];
    var requiredValidationOptions = fieldConfig["required"];
    var typeValidationOptions = fieldConfig["type"];
    if (!typeValidationOptions) {
        throw new Error("\"You have to specified the type of the field \"" + fieldName + "\". The type can take one of the following value : \"" + Object.keys(validators_map_1.validatorsMap).join('" | "') + "\"");
    }
    var type = typeValidationOptions[0];
    var typeErrorMsg = typeValidationOptions[1];
    if (!(type in validators_map_1.validatorsMap)) {
        throw Error("\"" + type + "\" is not a validation type. The type can only take one of the following value : \"" + Object.keys(validators_map_1.validatorsMap).join('" | "') + "\"");
    }
    if (!typeErrorMsg) {
        throw Error("A validation error message is required for the type.");
    }
    var availableValidators = validators_map_1.validatorsMap[type];
    var validatorKeys = Object.keys(fieldConfig).filter(function (k) { return k != "type" && k != "required"; });
    var typeValidationFunc = availableValidators["type"];
    if (requiredValidationOptions) {
        var requiredErrorMsg_1 = requiredValidationOptions[0];
        if (!requiredErrorMsg_1) {
            throw Error("A validation error message is required for the 'required' field.");
        }
        var requiredValidationFunc_1 = availableValidators["required"];
        validationsPipeLine.push(function (valueToValidate) {
            var isValid = requiredValidationFunc_1(valueToValidate);
            return isValid ? null : requiredErrorMsg_1;
        });
    }
    else {
        var optionalValidationFunc_1 = availableValidators["optional"];
        validationsPipeLine.push(function () {
            return optionalValidationFunc_1();
        });
    }
    validationsPipeLine.push(function (valueToValidate) {
        var isValid = typeValidationFunc(valueToValidate);
        return isValid ? null : typeErrorMsg;
    });
    validatorKeys.forEach(function (key) {
        var validatorFunction = availableValidators[key];
        if (!validatorFunction || typeof validatorFunction !== "function") {
            throw Error("\"" + key + "\" is not a possible validation key of the type \"" + type + "\". Possible value are : \"" + Object.keys(availableValidators).join('" | "') + "\"");
        }
        var validationOptions = fieldConfig[key];
        var expectNumberOfParams = validatorFunction.length;
        if (validationOptions.length !== expectNumberOfParams) {
            if ((validatorFunction.name === "hasMinLength" ||
                validatorFunction.name === "hasMaxLength") &&
                (validationOptions.length < expectNumberOfParams - 1 ||
                    validationOptions.length > expectNumberOfParams)) {
                throw new Error("Invalid number of arguments. The '" + key + "' validator of '" + type + "' type required " + (expectNumberOfParams - 1) + " argument(s).");
            }
            else if (validatorFunction.name !== "hasMinLength" &&
                validatorFunction.name !== "hasMaxLength") {
                throw new Error("Invalid number of arguments. The '" + key + "' validator of '" + type + "' type required " + expectNumberOfParams + " argument(s).");
            }
        }
        var validationFuncArgs = validationOptions.slice(0, validationOptions.length - 1);
        if (validatorFunction.name === "isInRange") {
            var min = validationFuncArgs[0], max = validationFuncArgs[1];
            if (min > max) {
                throw new Error("For range validator, the range minimum value i.e \"" + max + "\" must be lower than the range maximum value i.e \"" + min + "\"");
            }
        }
        var errorMsg = validationOptions[validationOptions.length - 1];
        if (typeof errorMsg !== "string") {
            throw Error("A validation error message must be a string.");
        }
        validationsPipeLine.push(function (valueToValidate) {
            var isValid = validatorFunction.apply(void 0, __spreadArray([valueToValidate], validationFuncArgs));
            return isValid ? null : errorMsg;
        });
    });
    return validationsPipeLine;
};
var createFieldsValidator = function (configObject) {
    var allFieldsValidator = {};
    for (var field in configObject) {
        var fieldConfig = configObject[field];
        allFieldsValidator[field] = createFieldValidator(fieldConfig, field);
    }
    return allFieldsValidator;
};
var createValidator = function (configObject) {
    var fieldsValidator = createFieldsValidator(configObject);
    var validate = function (objectToValidate) {
        var fieldsToValidate = Object.keys(configObject);
        var objectWithFieldsToValidate = {};
        fieldsToValidate.forEach(function (field) {
            objectWithFieldsToValidate[field] = objectToValidate[field];
        });
        var errors = [];
        for (var field in objectWithFieldsToValidate) {
            var validatorPipeline = fieldsValidator[field];
            var valueToValidate = objectWithFieldsToValidate[field];
            var validationFunc = validatorPipeline[0];
            var currentFieldErrMsg = validationFunc(valueToValidate);
            var start = 0;
            if (currentFieldErrMsg == "OPTIONAL") {
                var valueType = typeof valueToValidate;
                if (valueType === "undefined" || valueToValidate === null) {
                    start = validatorPipeline.length;
                }
                else {
                    start = 1;
                }
            }
            for (var i = start; i < validatorPipeline.length; i++) {
                var validationFunc_1 = validatorPipeline[i];
                var currentFieldErrMsg_1 = validationFunc_1(valueToValidate);
                if (currentFieldErrMsg_1) {
                    errors.push({
                        field: field,
                        error: currentFieldErrMsg_1
                            .replace(/\{\{field\}\}/g, field)
                            .replace(/\{\{value\}\}/g, valueToValidate),
                    });
                    break;
                }
            }
        }
        return errors;
    };
    return {
        validate: validate,
    };
};
exports.createValidator = createValidator;
