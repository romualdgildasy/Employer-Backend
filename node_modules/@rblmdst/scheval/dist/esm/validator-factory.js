import { validatorsMap } from "./validators-map";
const createFieldValidator = (fieldConfig, fieldName) => {
    const validationsPipeLine = [];
    const requiredValidationOptions = fieldConfig["required"];
    const typeValidationOptions = fieldConfig["type"];
    if (!typeValidationOptions) {
        throw new Error(`"You have to specified the type of the field "${fieldName}". The type can take one of the following value : "${Object.keys(validatorsMap).join('" | "')}"`);
    }
    const type = typeValidationOptions[0];
    const typeErrorMsg = typeValidationOptions[1];
    if (!(type in validatorsMap)) {
        throw Error(`"${type}" is not a validation type. The type can only take one of the following value : "${Object.keys(validatorsMap).join('" | "')}"`);
    }
    if (!typeErrorMsg) {
        throw Error(`A validation error message is required for the type.`);
    }
    const availableValidators = validatorsMap[type];
    const validatorKeys = Object.keys(fieldConfig).filter((k) => k != "type" && k != "required");
    const typeValidationFunc = availableValidators["type"];
    if (requiredValidationOptions) {
        const requiredErrorMsg = requiredValidationOptions[0];
        if (!requiredErrorMsg) {
            throw Error(`A validation error message is required for the 'required' field.`);
        }
        const requiredValidationFunc = availableValidators["required"];
        validationsPipeLine.push((valueToValidate) => {
            const isValid = requiredValidationFunc(valueToValidate);
            return isValid ? null : requiredErrorMsg;
        });
    }
    else {
        const optionalValidationFunc = availableValidators["optional"];
        validationsPipeLine.push(() => {
            return optionalValidationFunc();
        });
    }
    validationsPipeLine.push((valueToValidate) => {
        const isValid = typeValidationFunc(valueToValidate);
        return isValid ? null : typeErrorMsg;
    });
    validatorKeys.forEach((key) => {
        const validatorFunction = availableValidators[key];
        if (!validatorFunction || typeof validatorFunction !== "function") {
            throw Error(`"${key}" is not a possible validation key of the type "${type}". Possible value are : "${Object.keys(availableValidators).join('" | "')}"`);
        }
        const validationOptions = fieldConfig[key];
        const expectNumberOfParams = validatorFunction.length;
        if (validationOptions.length !== expectNumberOfParams) {
            if ((validatorFunction.name === "hasMinLength" ||
                validatorFunction.name === "hasMaxLength") &&
                (validationOptions.length < expectNumberOfParams - 1 ||
                    validationOptions.length > expectNumberOfParams)) {
                throw new Error(`Invalid number of arguments. The '${key}' validator of '${type}' type required ${expectNumberOfParams - 1} argument(s).`);
            }
            else if (validatorFunction.name !== "hasMinLength" &&
                validatorFunction.name !== "hasMaxLength") {
                throw new Error(`Invalid number of arguments. The '${key}' validator of '${type}' type required ${expectNumberOfParams} argument(s).`);
            }
        }
        const validationFuncArgs = validationOptions.slice(0, validationOptions.length - 1);
        if (validatorFunction.name === "isInRange") {
            const [min, max] = validationFuncArgs;
            if (min > max) {
                throw new Error(`For range validator, the range minimum value i.e "${max}" must be lower than the range maximum value i.e "${min}"`);
            }
        }
        const errorMsg = validationOptions[validationOptions.length - 1];
        if (typeof errorMsg !== "string") {
            throw Error(`A validation error message must be a string.`);
        }
        validationsPipeLine.push((valueToValidate) => {
            const isValid = validatorFunction(valueToValidate, ...validationFuncArgs);
            return isValid ? null : errorMsg;
        });
    });
    return validationsPipeLine;
};
const createFieldsValidator = (configObject) => {
    const allFieldsValidator = {};
    for (let field in configObject) {
        const fieldConfig = configObject[field];
        allFieldsValidator[field] = createFieldValidator(fieldConfig, field);
    }
    return allFieldsValidator;
};
export const createValidator = (configObject) => {
    const fieldsValidator = createFieldsValidator(configObject);
    const validate = (objectToValidate) => {
        const fieldsToValidate = Object.keys(configObject);
        const objectWithFieldsToValidate = {};
        fieldsToValidate.forEach((field) => {
            objectWithFieldsToValidate[field] = objectToValidate[field];
        });
        const errors = [];
        for (let field in objectWithFieldsToValidate) {
            const validatorPipeline = fieldsValidator[field];
            const valueToValidate = objectWithFieldsToValidate[field];
            const validationFunc = validatorPipeline[0];
            const currentFieldErrMsg = validationFunc(valueToValidate);
            let start = 0;
            if (currentFieldErrMsg == "OPTIONAL") {
                const valueType = typeof valueToValidate;
                if (valueType === "undefined" || valueToValidate === null) {
                    start = validatorPipeline.length;
                }
                else {
                    start = 1;
                }
            }
            for (let i = start; i < validatorPipeline.length; i++) {
                const validationFunc = validatorPipeline[i];
                const currentFieldErrMsg = validationFunc(valueToValidate);
                if (currentFieldErrMsg) {
                    errors.push({
                        field,
                        error: currentFieldErrMsg
                            .replace(/\{\{field\}\}/g, field)
                            .replace(/\{\{value\}\}/g, valueToValidate),
                    });
                    break;
                }
            }
        }
        return errors;
    };
    return {
        validate,
    };
};
